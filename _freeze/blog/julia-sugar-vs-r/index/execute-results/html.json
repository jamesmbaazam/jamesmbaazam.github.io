{
  "hash": "7f2ef35af2bdf718fe5f4e233beb6cae",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Julia vs. R (in my beginner's opinion)\"\nauthor:\n  - name: \"James Mba Azam\"\n  - orcid: \"0000-0001-5782-7330\"\ndate: \"2025-11-08\"\ncategories: [R, julia]\nformat:\n  html: \n    toc: true\nfreeze: true\n---\n\n\n\nI've heard a lot of good things about the [julia programming language](https://julialang.org/) over the last several years, but I've not bothered to learn it yet. Usually, my principle is that I only learn a new language or tool (or stack as the cool guys would call it) when I need it but not because everyone is raving about it.\n\nThe appealing features of julia that I hear a lot about are its computational speed (apparrently as fast as C/C++!), composability thorough [multiple dispatch](https://en.wikipedia.org/wiki/Multiple_dispatch) (wth is even that!!!), reproducibility features, and readability (easier syntax).\n\nThese are all attractive features that I want to harness moving forward, so a natural thing to do is to compare it to languages that I'm more familiar with.\n\nIn this post, I do a quick and dirty comparison of julia to R. This is not novel as others have written about it[^1][^2][^3], including [the official comparison](https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-R) by the julia folks. However, this is my own way of learning as I go, so forgive me if none of this is new to you but I'd still love to hear your thoughts.\n\nIs there anything non-factual or unfair about my comparisons? Do share your thoughts below or wherever I shared this post. \n\n## Autoprinting on assignment\n\nIn julia, objects are auto-printed when created but you can suppress it by ending the line with `;` like other programming languages. In R, objects have to be printed explicitly.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n### Julia\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nname = \"James\";\noranges = 3;\nmangoes = 2;\n\"$name bought $oranges oranges and $mangoes mangoes\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\"James bought 3 oranges and 2 mangoes\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n### R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- \"James\" # Not printed\n# You have to explicitly print the object by calling it or passing it to print\nname\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"James\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"James\"\n```\n\n\n:::\n:::\n\n\n:::\n\n### My judgment\n\nI find julia's feature a little annoying especially for data science projects.\n::::\n\n## String interpolation\n\nIn julia, you can insert/interpolate variables into a string using the `$` sign. You can do the same in R either using inbuilt functions like `paste()`, `paste0()`, `sprintf()`, or with external packages such as the `{glue}` R package.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n### Julia\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nname = \"James\";\noranges = 3;\nmangoes = 2;\n\"$name bought $oranges oranges and $mangoes mangoes\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\"James bought 3 oranges and 2 mangoes\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n### R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- \"James\"\noranges <- 3\nmangoes <- 2\nsprintf(\"%s bought %s oranges and %s mangoes\", name, oranges, mangoes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"James bought 3 oranges and 2 mangoes\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(name, \"bought\", oranges, \"oranges\", \"and\", mangoes, \"mangoes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"James bought 3 oranges and 2 mangoes\"\n```\n\n\n:::\n:::\n\n\n:::\n\n### My judgment\n\nUsing `paste()` or `paste0` can be a bit tedious but `sprintf()` is definitely a nice contender. Overall, julia is still easier to type.\n::::\n\n## Nexted `for` loops\n\nSay I want to populate a matrix where each element is the sum of its row and column indices.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n### Julia\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nA = 3;\nB = 3;\nM = [i+j for i in 1:A, j in 1:B]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3×3 Matrix{Int64}:\n 2  3  4\n 3  4  5\n 4  5  6\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n### R\n\n### R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- 3\nB <- 3\nM <- matrix(\n  0,\n  nrow = A,\n  ncol = B\n)\n\nfor (i in 1:A) {\n  for (j in 1:B) {\n    M[i, j] <- i + j\n  }\n}\n\nprint(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    3    4    5\n[3,]    4    5    6\n```\n\n\n:::\n:::\n\n\n:::\n\n### My judgment\n\nThe array comprehension method in julia makes it incredibly easy to write complicated nested for loops, so julia wins here again.\n::::\n\n## Inbuilt Reproducibility features\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n### Julia\n\nJulia has inbuilt functionalities to create a project-specific `Manifest.toml` for pinning the packages and versions used. This great for reproducibility and portability purposes. You can also create a `Project.toml` file to store information about the project.\n\nIn your command line, type (sequentially)\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n]\nactivate <path-to-project> # take snapshot of a project\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n### R\n\nR has no inbuilt functionalities for this. You can, however, use packages such as `{renv}` to pin your package versions for reproducibility.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!require(renv)) install.packages(\"renv\")\nlibrary(renv)\nrenv::activate()\n```\n:::\n\n\n:::\n\n### My judgment\n\nIt's quite clear that having to choose a package that works for you with minimal cognitive load is quite daunting for a new/intermediate user of R. Moreover, you also have to worry about the version of the package used for taking the snapshot itself. All these make it a little less desirable. Julia's inbuilt features for snapshoting a project make it more desirable for conducting reproducible research.\n::::\n\n:::: {.columns}\n## Package ecosystem and community \n\n::: {.columns width=\"50%\"}\n### R\n\nR has the tidyverse and other communities who have spent dedicated time developing transformational packages. The community is relatively large with an uncountable number of packages for doing data statistics, data science, and even general purpose programming including web development.\n:::\n\n::: {.columns width=\"50%\"}\n### julia\n\nJulia is a much younger language but that is not always a bad thing. Being a more recent language means the core developers have the opportunity to incorporate features from existing languages in order to give secondary developers and users a better experience. \n:::\n\n::::\n\n## Package management\n\n:::: {.columns}\n::: {.columns width=\"50%\"}\n### R\n\nWhen you try to load a package that's not yet been installed, R's error message could be more informative by informing you if the package exists but not installed.\n\n\"there is no package called ...\". Is not really a useful error message especially for beginners.\n\n![R package loading error](R_package_error_message.png)\n:::\n\n::: {.columns width=\"50%\"}\n### Julia\n\nJulia has a more informative package loading error because it checks the registry to see if the package exists and gives you a simple walkthrough to install it.\n\n![Julia package loading error](Julia_package_error_message.png)\n:::\n::::\n\n\n[^1]: [Coursera: Julia vs. R: What’s the Difference?](https://www.coursera.org/articles/julia-vs-r)\n[^2]: [First Impressions of Julia from an R User](https://mdneuzerling.com/post/first-impressions-of-julia-from-an-r-user/)\n[^3]: [Noteworthy differences from R in the Julia Official docs](https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-R)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}